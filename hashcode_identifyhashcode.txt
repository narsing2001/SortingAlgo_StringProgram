ğŸ”¹ 1. hashCode()
----------------------------------------------
Defined in: java.lang.Object (and can be overridden)
â¤ Meaning: Represents a logical hash code of an object.

It is meant to be overridden in classes that want to define equality based on content rather than reference (for example, String, Integer, or any custom class overriding equals()).

â¤ Behavior:

By default, Object.hashCode() returns a value derived from the objectâ€™s memory address.
But if a class overrides it (like String, Integer, HashMap, etc.), the result depends on the objectâ€™s data/content, not its memory address.

â¤ Example:
String s1 = new String("Hello");
String s2 = new String("Hello");

System.out.println(s1.hashCode()); // same (content-based)
System.out.println(s2.hashCode()); // same


Even though s1 and s2 are different objects, they produce the same hash code because String overrides hashCode() based on content.

ğŸ”¹ 2. System.identityHashCode(Object obj)
-------------------------------------------------
Defined in: java.lang.System

â¤ Meaning:
Returns the original, identity-based hash code of the object â€” the same as what Object.hashCode() would return if it hadnâ€™t been overridden.
This cannot be overridden. It always reflects the objectâ€™s identity (often linked to memory address).

â¤ Behavior:
Ignores any hashCode() override.
Useful when you need to distinguish objects by reference, not content (e.g., when debugging identity issues).

â¤ Example:
String s1 = new String("Hello");
String s2 = new String("Hello");

System.out.println(s1.hashCode());                // same (content-based)
System.out.println(s2.hashCode());                // same
System.out.println(System.identityHashCode(s1));  // different (based on object identity)
System.out.println(System.identityHashCode(s2));  // different

ğŸ”¸ Summary Table
Feature             	                 hashCode()	                            System.identityHashCode(obj)
--------------------------------------------------------------------------------------------------------------------
Can be overridden	                     âœ… Yes	                                âŒ No
Based on	                             Logical (content)	                    Physical (object identity)
Used in	Hash-based collections (e.g.     HashMap, HashSet)	                    When you need identity-based distinction
Returns same value for equal objects?	 Usually yes (if overridden properly)	Not necessarily

------------------------------------------------------------------------------------------------------------
âœ… When to Use Each
hashCode() â†’ normal use in collections, equality checks, etc.
System.identityHashCode() â†’ when debugging, or when working with identity-sensitive logic (e.g., using IdentityHashMap).
------------------------------------------------------------------------------------------------------------------------
Excellent â€” this is a very common Java interview topic, and interviewers often test whether you understand the difference between logical equality (equals() and hashCode()) 
vs object identity (== and System.identityHashCode()).

Letâ€™s go through a complete example with code, explanation, and how you can confidently answer it in an interview ğŸ‘‡

ğŸ’¡ Interview Question
=>
Q1: Whatâ€™s the difference between hashCode() and System.identityHashCode() in Java?
Can you show it with an example?

ğŸ§© Example Code
public class HashCodeExample {
    public static void main(String[] args) {
        String s1 = new String("Java");
        String s2 = new String("Java");

        System.out.println("s1.equals(s2): " + s1.equals(s2));
        System.out.println("s1 == s2: " + (s1 == s2));

        System.out.println("s1.hashCode(): " + s1.hashCode());
        System.out.println("s2.hashCode(): " + s2.hashCode());

        System.out.println("System.identityHashCode(s1): " + System.identityHashCode(s1));
        System.out.println("System.identityHashCode(s2): " + System.identityHashCode(s2));
    }
}

ğŸ§  Expected Output (approx)
s1.equals(s2): true
s1 == s2: false
s1.hashCode(): 2301506
s2.hashCode(): 2301506
System.identityHashCode(s1): 1836019240
System.identityHashCode(s2): 1028566121

ğŸ” Explanation (how to say it in an interview)

âœ… s1.equals(s2) â†’ true
Because both strings have the same content (â€œJavaâ€). The String class overrides equals() to compare content.

âœ… s1 == s2 â†’ false
Because they are two different objects in memory (new String("Java") creates separate instances).

âœ… s1.hashCode() and s2.hashCode() â†’ same
Because the String class overrides hashCode() to return a value based on the stringâ€™s content.
Even though theyâ€™re different objects, their contents are the same, so hash codes are identical.

âœ… System.identityHashCode(s1) and System.identityHashCode(s2) â†’ different
Because this method ignores overrides and returns a hash code based on the objectâ€™s identity (like its memory reference).
Itâ€™s what youâ€™d get if hashCode() were not overridden.

ğŸ—£ï¸ How to Answer in an Interview

Hereâ€™s a strong, concise way to phrase it:

â€œThe hashCode() method can be overridden to provide a logical hash code â€” usually based on an objectâ€™s content.
But System.identityHashCode() always returns the hash code based on the objectâ€™s identity, as if Object.hashCode() were used directly.
So if a class overrides hashCode(), both methods may return different values for the same object.â€

Then you can add:

â€œFor example, two different String objects with the same value have equal hashCode() but different System.identityHashCode() values.â€

âš™ï¸ Real-World Application

hashCode() â†’ Used by HashMap, HashSet, etc., to find buckets based on object content.
System.identityHashCode() â†’ Used by IdentityHashMap, which compares object references, not content.
---------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ’¡ Interview Follow-up Question

Q: Whatâ€™s the difference between HashMap and IdentityHashMap in Java?
Can you show with an example how hashCode() and System.identityHashCode() behave differently in them?

ğŸ§© Example Code
import java.util.HashMap;
import java.util.IdentityHashMap;

public class IdentityHashCodeDemo {
    public static void main(String[] args) {
        String key1 = new String("Java");
        String key2 = new String("Java");

        // Using HashMap (uses equals() and hashCode())
        HashMap<String, String> hashMap = new HashMap<>();
        hashMap.put(key1, "HashMap Value 1");
        hashMap.put(key2, "HashMap Value 2");

        // Using IdentityHashMap (uses == and System.identityHashCode())
        IdentityHashMap<String, String> identityMap = new IdentityHashMap<>();
        identityMap.put(key1, "IdentityMap Value 1");
        identityMap.put(key2, "IdentityMap Value 2");

        System.out.println("HashMap size: " + hashMap.size());
        System.out.println("HashMap content: " + hashMap);

        System.out.println("IdentityHashMap size: " + identityMap.size());
        System.out.println("IdentityHashMap content: " + identityMap);
    }
}

ğŸ§  Expected Output
HashMap size: 1
HashMap content: {Java=HashMap Value 2}

IdentityHashMap size: 2
IdentityHashMap content: {Java=IdentityMap Value 1, Java=IdentityMap Value 2}

ğŸ” Explanation (how to explain in the interview)
1.âœ… HashMap
-------------------------
Q1).Uses equals() and hashCode() for key comparison.
=>
Since key1 and key2 are different objects but equal in content,
equals() returns true and their hashCode() values are the same.

Therefore, HashMap treats them as the same key â†’ second value overwrites the first one.
Hence, size = 1.

2.âœ… IdentityHashMap
-------------------------------
Q2.Uses reference equality (==) instead of equals().
=>
Uses System.identityHashCode() instead of overridden hashCode().
key1 and key2 are different objects, so theyâ€™re treated as different keys.

Therefore, both entries are stored â†’ size = 2.

ğŸ—£ï¸ How to Answer This in an Interview
=>
Hereâ€™s a strong, clear way to respond:
----------------
â€œHashMap uses equals() and hashCode() to compare keys, so it treats two objects with the same content as the same key.
But IdentityHashMap uses == and System.identityHashCode(), meaning it compares keys by their reference, not content.
So two distinct String objects with the same text will be treated as different keys in an IdentityHashMap.â€

Then you can add:

â€œIn other words, IdentityHashMap is useful when you want to distinguish between different object instances, even if they look the same logically.â€

âš™ï¸ Summary Table
Feature	                HashMap	                            IdentityHashMap
--------------------------------------------------------------------------------------------------
Key comparison	        equals()	                        ==
Hash function	        hashCode()	                        System.identityHashCode()
Key uniqueness	        Based on content	                Based on object identity
Common use	            Regular maps (content-based keys)	Object identity tracking, caching, frameworks
-----------------------------------------------------------------------------------------------------------------